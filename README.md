# Python Monorepo

A Python monorepo is a single repository containing multiple projects, making it easier to manage and update them together.

This repository is a lightweight template showcasing how to structure a Python monorepo in a scalable way.

## Project structure

The root directory of a generic Python project `baz` in the monorepo has the following structure:

```
baz/
├─── src/
│    └─── org/path/to/baz
│         ├─── __init__.py
│         └─── ...
├─── assets/
│    └─── ...
├─── pyproject.toml
├─── poetry.lock
├─── Makefile
├─── .black.toml
└─── .ruff.toml
```

The `src` directory contains the source code of the project.
The presence of the chain of directories `org/path/to/baz` reflects in the module path of the project `org.path.to.baz`.
This effectively embeds the project as part of a single hierarchy of modules rooted in `org` for the user, while preserving separations from other projects in the monorepo for the maintainer.

The `assets` directory contains files used by the project that are not Python code.
Not all projects need this directory, so its presence is optional.

The `pyproject.toml` file is used by [Poetry](https://python-poetry.org/).
It contains metadata for the project and its dependencies.
The `poetry.lock` file is the resolution of dependencies generated by Poetry.

The `Makefile` file defines commands for the project like installation and code linting.
We use [Black](https://black.readthedocs.io) for formatting (config file `.black.toml`), [mypy](https://mypy-lang.org) for typing, and [Ruff](https://docs.astral.sh/ruff/) for other types of linting like import sorting (config file `.ruff.toml`).

## Installing other monorepo packages as dependencies

Some of the packages in the monorepo, such as internal libraries, will be installed by other projects.
To keep things simple, packages in the monorepo are not published to a package index and are instead installed by specifying their relative path in the monorepo.
This makes it easy to have a clear view of the whole code we are running and promotes alignment of dependencies across different projects.
It also allows packages to store assets in their own project root, enhancing cohesiveness.

We also install monorepo packages in editable mode.
The benefits of this are twofold: it allows packages to store assets in their own project root, enhancing cohesiveness, and it makes it easy to edit libraries on the go and immediately commit changes to git.

Note that, by installing a package with its path, we are effectively forcing all installing projects to share a single version of it: the one materialized in the last git commit.
It is important to keep this in mind, as breaking changes should ideally be addressed in all installing projects in the same pull request to not break anything.

Since only the last version of a package can be installed, a `CHANGELOG.md` file listing changes of each version loses some of its effectiveness.
Still, it might be beneficial to have one to make it easy for other devs to learn what's new in a library, especially in the case of a large monorepo.

## Using Breadcrumbs

There might be some cases where we would like to reference a file that requires navigating upwards in the directory structure of the monorepo.

As an example, consider the need to symlink the common configuration file `.ruff.toml` found at the root of the monorepo for each project root.
The common solution would be to use a symlink of the form `../../.ruff.toml` to point to this file.
Unfortunately, having sequences of `../` in a path has a series of disadvantages.
For example, after refactoring the directory structure, the path might break in unexpected and unsafe ways, potentially pointing outside of the monorepo.

To address this, we can use [Breadcrumbs](https://github.com/niqodea/breadcrumbs) to turn the series of `../` into a safer, more readable `.root.bc`.
We can then symlink the configuration file as `.root.bc/.ruff.toml`.

Other instances of upwards navigation in the monorepo, where Breadcrumbs might be useful, are installation of other monorepo packages via relative path and access to assets stored in the project root from the code in `src`.

## Monorepo structure

As an example, the monorepo in this repository divides projects in two categories:

- `apps`: applications for production features
- `libs`: libraries to be included as dependency of applications or other libraries

Each monorepo should be structured according to the nature of the projects and the needs of the team.
